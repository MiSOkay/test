---
layout: single
title: "📘 소프트웨어공학 중간고사 정리"
toc: true
toc_sticky: true
toc_label: "목차"
categories: school
excerpt: "소프트웨어공학 중간고사 정리 (1~5)"
tag: [school]
---
## 📘 Chapter 01. 소프트웨어공학 소개

### 🎯 학습 목표

- 소프트웨어와 시스템 개념 이해
- 소프트웨어 개발 작업과 위기 이해
- 소프트웨어공학의 접근법과 목표 파악

---

### 💡 1.1 소프트웨어란?

### ✅ 정의

> 소프트웨어 = 프로그램 + 개발·운용·보수에 필요한 모든 정보
> 
> 
> 눈에 보이지 않으며 구조가 코드 안에 숨어 있음
> 

### 📌 특징

- **복잡성**: 규모가 커질수록 비선형적으로 복잡해짐
- **순응성**: 다양한 요구사항에 맞춰야 함
- **변경성**: 외부 환경 변화에 따라 계속 수정됨
- **비가시성**: 물리적 형체가 없어 직관적으로 파악 어려움

### 📚 소프트웨어와 시스템

- 시스템: 특정 목적을 달성하기 위한 구성요소들의 결합체
- 소프트웨어는 시스템의 구성 요소 중 하나

---

### ⚙️ 1.2 소프트웨어 개발 작업

### 🔧 기본 활동

1. 요구 분석
2. 설계
3. 구현
4. 테스트
5. 유지보수

### ⚠️ 개발의 어려움

- 명세화, 재사용, 예측, 유지보수 모두 어려움
- 소프트웨어 위기: 수요와 복잡성 증가로 기존 방식의 한계

---

### 🧠 1.3 소프트웨어공학의 접근법

### ✅ 정의

> SW의 개발, 운영, 유지보수, 소멸에 대한 체계적 접근법
> 

### 🎯 목표

- 복잡성 감소, 비용 최소화, 일정 단축
- 고품질 SW 개발, 대규모 프로젝트 관리

---

### 📌 1.4 주요 주제

- **단계적 프로세스**: 요구분석 → 설계 → 구현 → 테스트
- **품질보증**: 인스펙션, 테스팅 등
- **프로젝트 관리**: 계획 수립, 자원·일정·리스크 관리

---

### 🌐 1.5 관련 분야

- **기초 이론**: 컴퓨터공학 원리, 알고리즘 등
- **응용 도메인**: 특정 문제 해결 목적의 분야

---

## 📘 Chapter 02. 프로세스와 방법론

### 🎯 학습 목표

- 소프트웨어 생명주기의 개념 이해
- 다양한 프로세스 모델의 특성과 적용 사례 파악
- 프로세스와 방법론의 차이점 인식

---

### 🔁 2.1 소프트웨어 생명주기 (Software Life Cycle)

- SW 개발에 있어 전 과정을 체계화한 것
    
    → 요구분석 → 설계 → 구현 → 테스트 → 유지보수
    
- 생명주기의 목표: **효율적인 개발 관리** + **품질 보장**

---

### ⚙️ 2.2 프로세스 (Process)

- 정의: SW를 개발하고 유지보수하는 일련의 작업 절차
- 종류:
    - **프로젝트 중심 프로세스** : 개발 프로세스, 관리 프로세스
    - **기타 프로세스** : 프로세스 관리 프로세스, 형상 관리 프로세스
- 좋은 프로세스의 조건:
    - 예측 가능성, 테스트 용이성, 변경 지원, 결함 제거 용이성

---

### 🧱 2.3 주요 프로세스 모델

---

### 💧 Waterfall Model (폭포수 모델)

> 정형적이고 순차적인 전통 모델
> 
- **특징**
    - 요구 → 설계 → 구현 → 테스트 → 운용을 단계별로 수행
    - 각 단계가 끝나야 다음 단계로 진행 가능
- **장점**
    - 구조가 명확해 초보자에게 적합
    - 각 단계 산출물이 명확하여 관리가 쉬움
- **단점**
    - 요구사항 변경에 취약
    - 테스트가 끝 단계에서 진행되므로 오류 발견이 늦음
    - 반복적 피드백이 어려움
- **적용 사례**
    - 요구사항이 고정된 대규모, 장기 프로젝트

---

### 🔍 V Model

> 폭포수 모델에 검증을 강조한 확장형
> 
- **특징**
    - 각 개발 단계에 맞는 테스트 활동을 병렬로 배치
    - 좌측: 개발 / 우측: 테스트 대응
- **장점**
    - 요구사항 검증을 각 단계마다 수행
    - 오류를 조기에 발견 가능
- **단점**
    - 복잡한 구조로 인한 관리 어려움
    - 반복적인 요구사항 변경 반영은 여전히 어려움
- **적용 사례**
    - 품질이 매우 중요한 시스템(예: 항공, 의료, 자동차 제어 시스템)

---

### 🧪 Prototyping Model (프로토타이핑 모델)

> 시제품을 먼저 제작해 사용자 요구 확인
> 
- **특징**
    - 사용자 피드백을 통해 요구를 구체화
- **장점**
    - 요구사항 도출이 명확
    - 사용자 참여가 활발, 만족도 높음
- **단점**
    - 프로젝트 전체 구조가 불분명할 수 있음
    - 문서화와 관리 어려움
- **적용 사례**
    - 요구가 불확실한 신기술 기반 프로젝트

---

### 🌀 Spiral Model (나선형 모델)

> 리스크 분석 기반 반복 개발 모델
> 
- **특징**
    - 각 사이클마다: 목표 설정 → 리스크 분석 → 개발/검토 → 계획 수립
    - 반복을 통해 점진적 완성
- **장점**
    - 위험요소를 조기에 식별/해결
    - 대규모 시스템에 적합
- **단점**
    - 복잡하고 관리가 어려움
    - 리스크 분석 실패 시 피해 큼
- **적용 사례**
    - 리스크가 높은 고비용/대형 프로젝트

---

### 📈 Evolutionary Model (진화적 모델)

> 점진적 기능 확장 방식의 모델
> 
- **특징**
    - 핵심 기능 먼저 구현 후 점진적 기능 추가
- **장점**
    - 빠른 사용자 피드백 수용
    - 빠른 시장 진입 가능
- **단점**
    - 전체 구조 파악 어려움
    - 스코프 관리 미흡 시 끝이 없을 수 있음
- **적용 사례**
    - 빠른 제품 출시가 중요한 스타트업

---

### 🧩 Unified Process (통합 프로세스)

> 유스케이스 기반의 반복적 프로세스 모델
> 
- **4단계 구성**:
    1. 도입 (Inception)
    2. 정련 (Elaboration)
    3. 구축 (Construction)
    4. 전이 (Transition)
- **장점**
    - 반복 개발로 변경에 유연
    - 문서화가 잘 되어 학습 용이
- **단점**
    - 초반 설계 복잡, 적용 난이도 높음
    - 협업 및 커뮤니케이션에 대한 가이드 부족

---

### ⚡ Agile Process (애자일 프로세스)

> 변화 수용 + 사용자 중심의 민첩한 개발
> 
- **특징**
    - 반복 주기 (1~4주) 단위 개발
    - 실행 가능한 소프트웨어를 빠르게 배포
- **대표 기법**: XP, Scrum, Kanban
- **장점**
    - 요구사항 변경에 강함
    - 고객과의 커뮤니케이션 중시
- **단점**
    - 명확한 문서 부족
    - 큰 규모/복잡한 프로젝트에 적용 어려움

---

### 🛠️ 2.4 지원 프로세스 요약

- **형상관리**: 변경 추적 (Git, SVN 등)
- **품질보증**: 인스펙션, 리뷰, 테스트
- **프로세스 관리**: 표준화 및 개선

---

### 🧠 2.5 방법론

- **구조적 방법론**: 자료흐름도 → 구조도 (모듈 간 관계)
- **객체지향 방법론**: 클래스/객체 중심, 메시지 전달
- **정보공학 방법론**: 데이터 중심, 기업 전략 반영

---

## 📘 Chapter 03. 프로젝트 관리와 계획

---

### 🎯 학습 목표

- **프로젝트 관리의 목적과 구성 요소** 이해
- **계획 수립, 스케줄링, 비용 예측 기법**의 개념과 적용
- **프로젝트 조직 형태 및 실행·리스크 관리** 절차 숙지

---

### 📌 3.1 프로젝트 시작 (Initiating a Project)

### ✅ 목적

- 프로젝트의 가치, 위험, 타당성을 분석하여 시작 여부 결정

### 📚 고려 요소

| 항목 | 설명 |
| --- | --- |
| 제공 가치 | 프로젝트가 조직에 주는 효익 |
| 리스크 | 기술적, 자원적, 일정상의 위험 |

### 💡 가치 평가 방법

1. **투자회수기간 (Payback Period)**
2. **ROI (Return on Investment)**
3. **순수 현재 가치**
4. **SWOT**
5. **평가표** 

### 🧮 타당성 분석 구성

| 요소 | 설명 |
| --- | --- |
| SOW | 프로젝트 작업 명세 (Statement of Work) |
| 비즈니스 목표 | 수행 결과물의 기대 효과 |
| 예산 | 비용과 수익 구조 요약 |
| 일정 | 예상 소요 시간표 |
| 리스크 목록 | 예상되는 위험 요소 |
| 대안 | 구축 vs 구매 등 비교 |
| 평가 | 프로젝트 실행 여부 판단 기준 |

---

### 🗓️ 3.2 프로젝트 계획과 스케줄링

### ✅ 초기 계획 단계

1. **목표 설정**
2. **작업 정의 (Scope/WBS)**
3. **일정 수립 (Scheduling)**
4. **비용 추정**

### 📦 프로젝트 범위 정의

- 전체 시스템 기능 중 우선순위와 범위를 설정
- 예시: 수강신청 시스템 → 로그인, 조회, 수강 기능 포함

### 🪜 WBS (Work Breakdown Structure)

> 프로젝트 목표 달성을 위한 작업을 계층적으로 분할
> 
- 최종 산출물을 도출하기 위한 작업 단위(Task) 구조화
- 예시: 설계 → 화면 설계 / DB 설계 / API 설계 등

### 📊 스케줄링

| 활동 | 설명 |
| --- | --- |
| 의존 관계 파악 | 작업 간 선후 순서 정리 |
| CPM | 여유 시간 계산, 중요 경로 식별 |
| 자원 할당 | 각 작업에 인력/시간 분배 |
| 간트차트 | 작업 일정 시각화 도구 (시간 막대형) |

---

### 💰 3.3 비용 예측 기법

> 인력, 기간, 자원 등 투입 요소를 기반으로 총비용을 예측
> 

### 📌 기본 개념

- 노력(Effort), 자원(Resource), 기간(Duration)의 관계

> D = E / M
> 
> 
> (D: 기간, E: 노력, M: 인력)
> 

### 📚 주요 기법

| 기법 | 설명 |
| --- | --- |
| 전문가 판단 | 경험에 기반한 예측 |
| PERT | 세 가지 추정 (낙관, 비관, 기대값) 사용 |
| 알고리즘 기반 | 수식/통계 기반 자동 추정 (COCOMO 등) |

---

### 📐 COCOMO-81 (Constructive Cost Model)

- SW 규모에 따라 개발 노력을 수치화
- 공식:

> Effort = A × (Size)^B × M
> 
- Size: KDSI (1,000줄 단위의 소스코드)
- M: 보정 계수 (팀 역량, 툴, 제품 특성 등)

### 📈 노력 승수 (Cost Drivers)

| 구분 | 예시 항목 |
| --- | --- |
| 제품 특성 | RELY(신뢰성), CPLX(복잡도) |
| 플랫폼 | STOR(저장 요구), TIME(실시간 성능) |
| 인력 역량 | ACAP(분석 능력), PCAP(프로그래머 능력) |
| 프로젝트 환경 | TOOL(지원 도구), SCED(일정 압박) |

### ⚠️ COCOMO-81 단점

- 초기 단계에서 정확한 Size 예측이 어려움
- 모델 자체가 오래됨, 최신 SW 트렌드 반영 미흡

---

### 🧮 COCOMO II (1995 이후 개선판)

> 개발 단계에 따라 3가지 모델 제시:
> 

| 단계 | 특징 |
| --- | --- |
| 단계 1 | 프로토타입 중심: 응용점수 기반 추정 |
| 단계 2 | 초기 설계 단계: 구조·기능 단위 추정 |
| 단계 3 | 상세 설계 후: 완성된 정보 기반 |

### 🔍 기능점수법 (Function Point)

> 입력, 출력, 파일 수 등으로 기능 복잡도 측정
> 
- 언어에 따라 LOC로 변환 가능 (예: FP 1 = C언어 약 150 LOC)

- 외부 입력(External Input)
- 외부 출력(External Output)
- 내부 논리 파일(Internal Logical File)
- 외부 인터페이스 파일(External Interface File)
- 외부 조회(External Query)

| 언어 | LOC/FP |
| --- | --- |
| 어셈블리 | 324 |
| C | 150 |
| Pascal | 91 |
| Ada | 71 |

---

### 👥 3.4 프로젝트 팀 조직

### 📌 조직 구성의 핵심

- **역할과 책임의 분담**
- **정보 흐름과 결정 구조**
- **갈등 해결 방식 설정**

### 팀 구성 역할 예시

| 역할 | 설명 |
| --- | --- |
| 프로젝트 매니저 | 전체 일정/자원 관리 |
| 시스템 분석가 | 요구 분석 및 모델 설계 |
| 소프트웨어 엔지니어 | 구현 및 코딩 |
| DB 엔지니어 | 데이터베이스 설계 |
| QA 매니저 | 품질 및 테스트 책임 |
| 기술 지원 | 운영 중 장애 처리 |

### 📚 조직 형태

| 유형 | 설명 |
| --- | --- |
| 직능별 조직 | 기능별 부서 중심, 효율적이나 협업 느림 |
| 프로젝트별 조직 | 전담팀 구성, 커뮤니케이션 빠름, 프로젝트 관리 수월 |
| 매트릭스 조직 | 이중 소속 구조 (부서 + 프로젝트) |
| 애자일 조직 | 5~9명 소규모 팀, 자율성과 유연성 중심 |

---

### 🛠️ 3.5 실행과 모니터링

### 📌 실행

- 킥오프 미팅으로 시작
- 주기적으로 작업 결과 수집

### 📊 모니터링

| 항목 | 설명 |
| --- | --- |
| 일정 추적 | 작업 진척도 확인 |
| 어닝 밸류 분석 (EVM) | 계획 대비 실제 비용/성과 비교 분석 |

---

### ⚠️ 3.6 리스크 관리

### ✅ 목적

> 예측 가능한 위험을 사전에 파악하고 대응책을 마련해 피해 최소화
> 

### 📋 주요 단계

1. **리스크 파악**
    - 회의, 문서 분석, 체크리스트, 유추 등 사용
2. **리스크 평가**
    - 발생 확률 × 영향도로 우선순위 설정
    - 정성적(확률 없음) / 정량적 분석 모두 가능
3. **대응 전략 수립**

| 전략 | 설명 |
| --- | --- |
| 회피 | 아예 발생하지 않게 설계 변경 |
| 이전 | 보험, 외부 업체 위탁 등 |
| 완화 | 영향도를 줄이는 방식 |
| 수용 | 감수 가능한 수준일 때 그대로 진행 |

---

### 📑 프로젝트 계획서 구성

| 항목 | 구성 내용 |
| --- | --- |
| 개요 | 목적, 산출물, 정의 등 |
| 자원/일정 예측 | 인력, 비용, 기간 |
| 조직 구성 | 역할별 인력 배치 |
| WBS | 작업 세분화 |
| 기술관리 | 변경/위험/비용/문제점 관리 |
| 개발 절차 | 방법론, 단계 정의 |
| 검토 회의 | 일정, 후속조치 |
| 성능 시험/문서화 | 검증 방법 |
| 유지보수/설치 | 납품 이후 계획 |

---

## ✅ 마무리 요약

- **프로젝트 관리는 일정, 비용, 자원, 리스크의 통합 제어**
- **계획 수립(WBS, 일정, 비용)** → **실행** → **모니터링** → **피드백 반복**
- COCOMO, 기능점수법 등은 **실제 프로젝트에서 비용·노력 추정에 유용**
- 팀 구성은 프로젝트 성격에 맞춰 선택해야 하며, **유형별 장단점 파악 필수**

---

## 📘 Chapter 04. 요구 분석 (Requirements Analysis)

---

### 🎯 학습 목표

- **사용자의 요구를 추출하고 정리**하는 과정을 이해한다.
- **요구의 유형 및 분석 방법**을 설명할 수 있다.
- **유스케이스 모델링**을 통해 사용자 관점에서 시스템을 설명할 수 있다.
- **요구 명세서** 작성 기준(IEEE 830)을 이해하고 요구를 검증할 수 있다.

---

### 🧩 4.1 요구 (Requirements)

### ✅ 정의

> 시스템에 대한 사용자의 기대 및 요청을 명확하게 정의한 것
> 
> 
> 즉, “시스템이 무엇을 해야 하는가”에 대한 공식적 합의 사항
> 

### 💡 왜 중요한가?

- 프로젝트의 시작점이자 기준점
- 애매하거나 누락된 요구는 개발 실패의 원인

### 📌 제약조건 (Constraints)

- 특정 언어 사용, 플랫폼 제한, 법적/운영 환경 제약 등
- 요구사항과 함께 반드시 파악해야 하는 요소

---

### 📚 4.1 요구의 분류

| 유형 | 설명 | 예시 |
| --- | --- | --- |
| **기능적 요구** | 시스템이 수행해야 하는 기능 | ATM: 입금, 출금, 조회 |
| **비기능적 요구** | 성능, 보안, 사용성 등 품질 속성 | 응답시간 1초 이내, 암호화 적용 |
| **도메인 요구** | 해당 분야 특유의 업무 규칙 | 회계 규칙, 세금 계산 방식 |
| **명시적/암묵적 요구** | 명확히 주어진 것 vs 일반적으로 기대되는 것 | 명시적: UI 언어 / 암묵적: 웹 표준 준수 |

---

### 🔍 4.2 요구 추출 (Requirements Elicitation)

### 📌 추출 단계

1. **정보 출처 파악**
2. **정보 수집**
3. **요구와 제약사항 정의**

### 📋 요구 정보 출처

| 출처 | 설명 |
| --- | --- |
| 고객(Client) | 최종 사용자의 요구 표현자 |
| 도메인 전문가 | 해당 업무에 특화된 전문가 |
| 이해당사자(Stakeholder) | 시스템 사용/영향 받는 모든 사람 |
| 사용자(User) | 직접 사용하는 실무 담당자 |
| 역공학 | 기존 시스템에서 요구 파악 |

### 📚 수집 방법

| 방법 | 특징 |
| --- | --- |
| 인터뷰 | 가장 일반적, 개인별 상세 의견 확보 |
| 설문 | 대규모 집단 의견 수렴 |
| 문헌조사 | 유사 시스템 분석, 양식 검토 |
| 브레인스토밍 | 자유로운 아이디어 발산 |
| 관찰 | 사용자의 실제 행동 분석 |
| 프로토타이핑 | 시제품을 보여주며 피드백 획득 |

---

### 🧠 4.3 요구 분석 (Requirements Analysis)

### ✅ 목적

- 요구사항을 **명확하고, 일관되며, 완전하게 정리**
- 요구 간 충돌 제거 및 우선순위 지정

### 📌 요구의 품질 속성

| 속성 | 설명 |
| --- | --- |
| **원자성 (Atomic)** | 요구는 더 이상 나눌 수 없는 최소 단위여야 함 |
| **완전성 (Complete)** | 누락된 항목이 없어야 함 |
| **비모호성 (Unambiguous)** | 해석이 명확해야 함 |
| **일관성 (Consistent)** | 충돌이나 모순이 없어야 함 |
| **추적 가능성 (Traceable)** | 구현, 테스트 항목으로 연결되어야 함 |
| **테스트 가능성 (Testable)** | 검증 가능한 요구여야 함 |
| **우선순위화 (Prioritized)** | 중요도에 따라 구분 가능해야 함 |

### 🧩 분석 기법

- **도메인 분석**: 분야별 핵심 개념 파악 → 시스템 개념화
- **시나리오 기반 분석**: 사용자 스토리/상황을 바탕으로 요구 도출

✅ 사용자 스토리 템플릿:

```
php-template
복사편집
<역할>은(는) <행위>를 하여 <목표>를 달성하고자 한다.
ex) 학생은 강의를 수강신청하여 원하는 수업을 듣고자 한다.

```

---

### 🎭 4.4 유스케이스 (Use Case)

### ✅ 정의

> 사용자(액터)가 시스템과 상호작용하는 방식을 다이어그램과 시나리오로 표현
> 

### 📌 구성 요소

| 요소 | 설명 |
| --- | --- |
| 액터(Actor) | 시스템과 상호작용하는 외부 주체 |
| 유스케이스(Use Case) | 액터가 시스템을 통해 수행하는 작업 |
| 시스템 범위 | 시스템이 담당할 영역 정의 |
| 관계 | Include, Extend, Generalization 등 |

### 📌 유스케이스 작성 단계

1. **액터 식별**
    - 시스템을 사용하는 사용자 그룹, 외부 시스템 등
2. **유스케이스 도출**
    - 사용자가 시스템을 통해 달성하고자 하는 목적
3. **유스케이스 관계 설정**
    - 공통 동작은 *Include*, 조건부 확장은 *Extend*

### 🔗 관계 예시

| 관계 | 설명 | 예시 |
| --- | --- | --- |
| Include | 공통 기능을 재사용 | ‘결제’ 유스케이스가 ‘로그인’을 포함 |
| Extend | 조건부 확장 | ‘결제’ 중 ‘멤버십 할인’은 조건부 수행 |

---

### 📑 4.5 요구 명세 (IEEE 830)

> 요구사항을 정형화하여 문서로 명세화 (SRS = Software Requirements Specification)
> 

### 📄 주요 구성

1. 개요
    - 시스템 목적, 범위, 정의, 약어
2. 기능 요구
    - 사용자 인터페이스, 하드웨어/소프트웨어 인터페이스, 기능 목록
3. 기타 요구 및 제약조건
    - 성능 요구, 예외 처리, 자원 제한 등
4. 인수 조건
    - 시험 조건 명시
5. 참고 자료
    - 관련 문서, 부록

### ✍ 작성 시 유의사항 (by Gilbert)

- 이해하기 쉽게
- 사용자와 개발자 간 **동의된 조건**
- 테스트 기준과 품질 조건 포함
- 시스템이 수행할 모든 기능을 빠짐없이 포함

---

### ✅ 4.6 요구 검증 (Requirements Validation)

> 도출된 요구사항이 정확하고 실현 가능한지를 점검하는 절차
> 

### 📌 주요 검증 활동

| 기법 | 설명 |
| --- | --- |
| 리뷰 | 전문가 집단이 문서 점검 |
| 시뮬레이션 | 시스템 동작 예측을 통한 확인 |
| 프로토타이핑 | 간단한 시제품으로 검증 |
| 테스트 기준 설정 | 테스트 가능성 있는 요구인지 확인 |

### ⚠️ 검증의 초점

- 요구가 모순 없이 완전한가?
- 사용자가 실제 원했던 기능인가?
- 구현이 가능한 수준인가?

---

## ✅ 마무리 요약

- 요구 분석은 시스템 개발의 **출발점이자 핵심 기반**
- 다양한 출처로부터 요구를 **정확히 추출 → 분석 → 정리 → 검증**
- **유스케이스와 요구 명세서**는 개발 문서의 기준이자 계약서 역할
- 요구 검증을 통해 **초기 실수로 인한 재작업 비용 방지**

---

## 📘 Chapter 05. 요구 모델링 (Requirements Modeling)

---

### 🎯 학습 목표

- 소프트웨어 요구사항을 **시각적으로 표현**하고 **정의**할 수 있다.
- UML을 활용한 **정적 / 동적 / 제어 모델**을 작성할 수 있다.
- 모델 간 **일관성 검토 및 검증** 절차를 이해한다.

---

### 🧾 5.1 모델링 기초

### ✅ 모델링이 필요한 이유

| 목적 | 설명 |
| --- | --- |
| 복잡도 관리 | 대규모 시스템의 구조와 흐름을 추상화 |
| 시각화 | 무형의 SW를 다이어그램으로 표현 |
| 의사소통 | 고객, 개발자 간 공통 이해 도출 |
| 이해도 향상 | 문제 도메인 및 설계 대상 시스템을 파악 |
| 사전 검증 | 구현 전에 설계상의 오류를 파악 |
| 문서화 | 기존 시스템 분석 및 기록용 |

### 📌 관점과 추상화 수준

- 시스템은 **여러 관점**에서 **다양한 추상화 수준**으로 모델링됨
    
    (예: 사용자 관점, 구조 관점, 행위 관점 등)
    

---

### 🧠 5.2 UML (Unified Modeling Language)

> 객체지향 소프트웨어를 위한 표준 시각화 언어
> 

### ✅ UML의 특징

- 시스템의 다양한 측면을 시각적으로 표현
- 기능적, 구조적, 동적 관점 모두 지원
- 하드웨어 설계의 회로도와 유사한 개념

### 🔁 UML 모델링 과정 (7단계)

![image.png](attachment:834f4f4a-0c4d-48da-89be-0b21a8e0cc9e:image.png)

---

### 🏗️ 5.3 정적 모델링

> 시스템의 구조적 측면을 표현 (변하지 않는 부분)
> 

### 🔧 클래스 다이어그램

- 객체들의 공통 구조와 관계 표현
- 도메인 개념, 속성, 연관, 상속 등을 표현

### 🌟 주요 개념 정리

| 개념 | 설명 |
| --- | --- |
| 객체(Object) | 상태 + 동작 + 고유 ID를 가진 실체 |
| 클래스(Class) | 유사한 객체의 추상적 정의 |
| 캡슐화 | 속성과 연산을 하나로 묶음, 정보 은닉 |
| 연관(Association) | 객체 간 상호작용 관계 |
| 상속(Inheritance) | 상위 클래스의 속성/연산을 하위 클래스가 물려받음 |
| 다형성(Polymorphism) | 동일 메시지에 대해 객체별로 다른 반응 |

### 💡 표현법

- 클래스 = 이름 / 속성 / 오퍼레이션
- 관계: 연관 (실선), 상속 (화살표), 구현/의존(점선)

---

### 🔁 5.4 동적 모델링

> 시간의 흐름에 따라 바뀌는 시스템의 동작 표현
> 

### 📩 시퀀스 다이어그램

- 객체 간 메시지 교환 순서를 **시간 흐름에 따라 시각화**
- X축: 객체, Y축: 시간, 화살표: 메시지 흐름

### 🤝 협동 다이어그램

- 객체 간 **링크 구조 + 메시지 교환**을 동시에 표현

### 🔁 상태 다이어그램

- 객체의 상태 변화 과정을 **이벤트 기반으로 모델링**
- 예시: 도서 대출 시스템 → ‘보관 중’ → ‘대출 중’ → ‘반납 처리’

---

### 🔂 5.5 제어 모델링

> 활동 간의 제어 흐름을 시각화하는 모델
> 

### 🧭 액티비티 다이어그램

| 요소 | 설명 |
| --- | --- |
| 액티비티(Activity) | 작업 단위 (계산, 처리 등) |
| 전환(Transition) | 작업 완료 후 다음 작업으로 제어 이동 |
| 분기/병합 | 조건에 따른 흐름 제어 |
| 병렬 처리 | 동시 실행되는 작업 표현 가능 |
- 복잡한 **비즈니스 프로세스**, **워크플로우**에 적합

---

### ✅ 5.6 모델 검증

> 모델링 결과가 일관되고 정확한지를 확인하는 과정
> 

### 📝 검증 방법

| 방법 | 설명 |
| --- | --- |
| 리뷰 | 동료 검토, 워크스루, 인스펙션 등 |
| 테스트 | 모델 시뮬레이션 |
| 정형 기법 | 수학적 증명 기반 기법 |
| 프로토타이핑 | 모델 기반 실제 동작 확인 |
| 추적성 검사 | 요구사항 ↔ 모델 요소 일치 여부 확인 |

---

### 📌 일관성 체크 항목

| 비교 항목 | 확인 내용 |
| --- | --- |
| 유스케이스 ↔ 시퀀스 | 각 유스케이스에 대한 시퀀스 존재 여부 |
| 시퀀스 ↔ 클래스 | 메시지 교환 시 사용된 클래스가 클래스 다이어그램에 존재 |
| 클래스 ↔ 상태 다이어그램 | 상태 변화가 해당 클래스의 속성과 연관됨 |

---

## ✅ 마무리 요약

- 요구 모델링은 **고객과 개발자의 공통 이해 형성**과 **설계 검증**을 위한 핵심 활동
- UML을 활용하면 **정적/동적/제어적 측면**을 모두 시각화할 수 있음
- 다양한 다이어그램은 **서로 연결되고 검증 가능**해야 함 (일관성 중요)